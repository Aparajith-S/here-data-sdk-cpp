<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>olp-cpp-sdk: olp::dataservice::write::StreamLayerClient Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">olp-cpp-sdk
   &#160;<span id="projectnumber">0.6.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceolp.html">olp</a></li><li class="navelem"><b>dataservice</b></li><li class="navelem"><b>write</b></li><li class="navelem"><a class="el" href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html">StreamLayerClient</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">olp::dataservice::write::StreamLayerClient Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Client responsible for writing data into an OLP Stream Layer.  
 <a href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="StreamLayerClient_8h_source.html">StreamLayerClient.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7bd61c1e42386b50bcdf6476441de4c9"><td class="memItemLeft" align="right" valign="top"><a id="a7bd61c1e42386b50bcdf6476441de4c9"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FlushResponse</b> = std::vector&lt; <a class="el" href="classolp_1_1client_1_1ApiResponse.html">PublishDataResponse</a> &gt;</td></tr>
<tr class="separator:a7bd61c1e42386b50bcdf6476441de4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2c41ff2ddc4f22d5962021f7603356"><td class="memItemLeft" align="right" valign="top"><a id="aca2c41ff2ddc4f22d5962021f7603356"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FlushCallback</b> = std::function&lt; void(FlushResponse response)&gt;</td></tr>
<tr class="separator:aca2c41ff2ddc4f22d5962021f7603356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a325961466e55bddbd5f30fac4447db9a"><td class="memItemLeft" align="right" valign="top"><a id="a325961466e55bddbd5f30fac4447db9a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>FlushListener</b> = <a class="el" href="classolp_1_1dataservice_1_1write_1_1FlushEventListener.html">FlushEventListener</a>&lt; const FlushResponse &amp; &gt;</td></tr>
<tr class="separator:a325961466e55bddbd5f30fac4447db9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a631ec6c8beafe2e3efc742cd84f7b1f3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html#a631ec6c8beafe2e3efc742cd84f7b1f3">StreamLayerClient</a> (const <a class="el" href="classolp_1_1client_1_1HRN.html">client::HRN</a> &amp;catalog, const <a class="el" href="structolp_1_1client_1_1OlpClientSettings.html">client::OlpClientSettings</a> &amp;settings, const std::shared_ptr&lt; <a class="el" href="classolp_1_1cache_1_1KeyValueCache.html">cache::KeyValueCache</a> &gt; &amp;cache=CreateDefaultCache(), const <a class="el" href="structolp_1_1dataservice_1_1write_1_1FlushSettings.html">FlushSettings</a> &amp;flush_settings=<a class="el" href="structolp_1_1dataservice_1_1write_1_1FlushSettings.html">FlushSettings</a>())</td></tr>
<tr class="memdesc:a631ec6c8beafe2e3efc742cd84f7b1f3"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html" title="Client responsible for writing data into an OLP Stream Layer. ">StreamLayerClient</a> Constructor.  <a href="#a631ec6c8beafe2e3efc742cd84f7b1f3">More...</a><br /></td></tr>
<tr class="separator:a631ec6c8beafe2e3efc742cd84f7b1f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad132f0ced2ecd2653e892382d0df19d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classolp_1_1client_1_1CancellableFuture.html">olp::client::CancellableFuture</a>&lt; <a class="el" href="classolp_1_1client_1_1ApiResponse.html">PublishDataResponse</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html#ad132f0ced2ecd2653e892382d0df19d7">PublishData</a> (const <a class="el" href="classolp_1_1dataservice_1_1write_1_1model_1_1PublishDataRequest.html">model::PublishDataRequest</a> &amp;request)</td></tr>
<tr class="memdesc:ad132f0ced2ecd2653e892382d0df19d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call to publish data into an OLP Stream Layer.  <a href="#ad132f0ced2ecd2653e892382d0df19d7">More...</a><br /></td></tr>
<tr class="separator:ad132f0ced2ecd2653e892382d0df19d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a286f9164cedc1cb1e4cbc62f723bc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classolp_1_1client_1_1CancellationToken.html">olp::client::CancellationToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html#a7a286f9164cedc1cb1e4cbc62f723bc4">PublishData</a> (const <a class="el" href="classolp_1_1dataservice_1_1write_1_1model_1_1PublishDataRequest.html">model::PublishDataRequest</a> &amp;request, const PublishDataCallback &amp;callback)</td></tr>
<tr class="memdesc:a7a286f9164cedc1cb1e4cbc62f723bc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call to publish data into an OLP Stream Layer.  <a href="#a7a286f9164cedc1cb1e4cbc62f723bc4">More...</a><br /></td></tr>
<tr class="separator:a7a286f9164cedc1cb1e4cbc62f723bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4861fa47c43c36f1ccf18bf995ce8df4"><td class="memItemLeft" align="right" valign="top">boost::optional&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html#a4861fa47c43c36f1ccf18bf995ce8df4">Queue</a> (const <a class="el" href="classolp_1_1dataservice_1_1write_1_1model_1_1PublishDataRequest.html">model::PublishDataRequest</a> &amp;request)</td></tr>
<tr class="memdesc:a4861fa47c43c36f1ccf18bf995ce8df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Queue a PublishDataRequest to be sent over the wire at a later time.  <a href="#a4861fa47c43c36f1ccf18bf995ce8df4">More...</a><br /></td></tr>
<tr class="separator:a4861fa47c43c36f1ccf18bf995ce8df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad385249de0e58e5778a94ec4f28f7b93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classolp_1_1client_1_1CancellableFuture.html">olp::client::CancellableFuture</a>&lt; FlushResponse &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html#ad385249de0e58e5778a94ec4f28f7b93">Flush</a> ()</td></tr>
<tr class="memdesc:ad385249de0e58e5778a94ec4f28f7b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush PublishDataRequests which have been queued via the Queue API.  <a href="#ad385249de0e58e5778a94ec4f28f7b93">More...</a><br /></td></tr>
<tr class="separator:ad385249de0e58e5778a94ec4f28f7b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d4842797842ce752773f3c99a8d24f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classolp_1_1client_1_1CancellationToken.html">olp::client::CancellationToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html#ab0d4842797842ce752773f3c99a8d24f">Flush</a> (const FlushCallback &amp;callback)</td></tr>
<tr class="memdesc:ab0d4842797842ce752773f3c99a8d24f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush PublishDataRequests which have been queued via the Queue API.  <a href="#ab0d4842797842ce752773f3c99a8d24f">More...</a><br /></td></tr>
<tr class="separator:ab0d4842797842ce752773f3c99a8d24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11051813f007b732533edcd0a25ea493"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html#a11051813f007b732533edcd0a25ea493">Enable</a> (std::shared_ptr&lt; <a class="el" href="classolp_1_1dataservice_1_1write_1_1FlushEventListener.html">FlushListener</a> &gt; listener=nullptr)</td></tr>
<tr class="memdesc:a11051813f007b732533edcd0a25ea493"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable the <a class="el" href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html" title="Client responsible for writing data into an OLP Stream Layer. ">StreamLayerClient</a> auto-flushing mechanism.  <a href="#a11051813f007b732533edcd0a25ea493">More...</a><br /></td></tr>
<tr class="separator:a11051813f007b732533edcd0a25ea493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc62cef939043cc11ac68b2a78ce3b5"><td class="memItemLeft" align="right" valign="top">std::future&lt; void &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html#a0cc62cef939043cc11ac68b2a78ce3b5">Disable</a> ()</td></tr>
<tr class="memdesc:a0cc62cef939043cc11ac68b2a78ce3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disable the <a class="el" href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html" title="Client responsible for writing data into an OLP Stream Layer. ">StreamLayerClient</a> auto-flushing mechanism. Will cancel any ongoing background flush tasks.  <a href="#a0cc62cef939043cc11ac68b2a78ce3b5">More...</a><br /></td></tr>
<tr class="separator:a0cc62cef939043cc11ac68b2a78ce3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6e93843c9c391d4e4c482386abc743"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classolp_1_1client_1_1CancellableFuture.html">olp::client::CancellableFuture</a>&lt; <a class="el" href="classolp_1_1client_1_1ApiResponse.html">PublishSdiiResponse</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html#a7b6e93843c9c391d4e4c482386abc743">PublishSdii</a> (const <a class="el" href="classolp_1_1dataservice_1_1write_1_1model_1_1PublishSdiiRequest.html">model::PublishSdiiRequest</a> &amp;request)</td></tr>
<tr class="memdesc:a7b6e93843c9c391d4e4c482386abc743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call to send a list of SDII messages to an OLP Stream Layer. SDII message data must be in SDII MessageList protobuf format. For more information please see the OLP Sensor Data Ingestion Interface documentation and schemas.  <a href="#a7b6e93843c9c391d4e4c482386abc743">More...</a><br /></td></tr>
<tr class="separator:a7b6e93843c9c391d4e4c482386abc743"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21679e30d6bdbd2d8d15a1867ee4f848"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classolp_1_1client_1_1CancellationToken.html">olp::client::CancellationToken</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html#a21679e30d6bdbd2d8d15a1867ee4f848">PublishSdii</a> (const <a class="el" href="classolp_1_1dataservice_1_1write_1_1model_1_1PublishSdiiRequest.html">model::PublishSdiiRequest</a> &amp;request, const PublishSdiiCallback &amp;callback)</td></tr>
<tr class="memdesc:a21679e30d6bdbd2d8d15a1867ee4f848"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call to send a list of SDII messages to an OLP Stream Layer. SDII message data must be in SDII MessageList protobuf format. For more information please see the OLP Sensor Data Ingestion Interface documentation and schemas.  <a href="#a21679e30d6bdbd2d8d15a1867ee4f848">More...</a><br /></td></tr>
<tr class="separator:a21679e30d6bdbd2d8d15a1867ee4f848"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a77bbf0a7e2dfd992ef2e3aa81734b067"><td class="memItemLeft" align="right" valign="top">static std::shared_ptr&lt; <a class="el" href="classolp_1_1dataservice_1_1write_1_1FlushEventListener.html">FlushListener</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html#a77bbf0a7e2dfd992ef2e3aa81734b067">DefaultListener</a> ()</td></tr>
<tr class="memdesc:a77bbf0a7e2dfd992ef2e3aa81734b067"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a listener object of type <a class="el" href="classolp_1_1dataservice_1_1write_1_1DefaultFlushEventListener.html" title="Default implementation of the FlushEventListener. ">DefaultFlushEventListener</a> for this API.  <a href="#a77bbf0a7e2dfd992ef2e3aa81734b067">More...</a><br /></td></tr>
<tr class="separator:a77bbf0a7e2dfd992ef2e3aa81734b067"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Client responsible for writing data into an OLP Stream Layer. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a631ec6c8beafe2e3efc742cd84f7b1f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631ec6c8beafe2e3efc742cd84f7b1f3">&#9670;&nbsp;</a></span>StreamLayerClient()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">olp::dataservice::write::StreamLayerClient::StreamLayerClient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classolp_1_1client_1_1HRN.html">client::HRN</a> &amp;&#160;</td>
          <td class="paramname"><em>catalog</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structolp_1_1client_1_1OlpClientSettings.html">client::OlpClientSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>settings</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classolp_1_1cache_1_1KeyValueCache.html">cache::KeyValueCache</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em> = <code>CreateDefaultCache()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structolp_1_1dataservice_1_1write_1_1FlushSettings.html">FlushSettings</a> &amp;&#160;</td>
          <td class="paramname"><em>flush_settings</em> = <code><a class="el" href="structolp_1_1dataservice_1_1write_1_1FlushSettings.html">FlushSettings</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html" title="Client responsible for writing data into an OLP Stream Layer. ">StreamLayerClient</a> Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">catalog</td><td>OLP HRN specifying the catalog this client will write to. </td></tr>
    <tr><td class="paramname">settings</td><td>Client settings used to control behaviour of this <a class="el" href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html" title="Client responsible for writing data into an OLP Stream Layer. ">StreamLayerClient</a> instance. </td></tr>
    <tr><td class="paramname">cache</td><td>Optional KeyValueCache instance used for queuing. If no cache </td></tr>
    <tr><td class="paramname">flush_settings</td><td>Optional defines settings that effect cached partitions to be flushed. is provided a default in-memory cache is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a77bbf0a7e2dfd992ef2e3aa81734b067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77bbf0a7e2dfd992ef2e3aa81734b067">&#9670;&nbsp;</a></span>DefaultListener()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::shared_ptr&lt;<a class="el" href="classolp_1_1dataservice_1_1write_1_1FlushEventListener.html">FlushListener</a>&gt; olp::dataservice::write::StreamLayerClient::DefaultListener </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a listener object of type <a class="el" href="classolp_1_1dataservice_1_1write_1_1DefaultFlushEventListener.html" title="Default implementation of the FlushEventListener. ">DefaultFlushEventListener</a> for this API. </p>
<dl class="section return"><dt>Returns</dt><dd>std::shared_ptr&lt; FlushDataListener &gt; object, of appropriate type for this API. </dd></dl>

</div>
</div>
<a id="a0cc62cef939043cc11ac68b2a78ce3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc62cef939043cc11ac68b2a78ce3b5">&#9670;&nbsp;</a></span>Disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::future&lt;void&gt; olp::dataservice::write::StreamLayerClient::Disable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disable the <a class="el" href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html" title="Client responsible for writing data into an OLP Stream Layer. ">StreamLayerClient</a> auto-flushing mechanism. Will cancel any ongoing background flush tasks. </p>
<dl class="section return"><dt>Returns</dt><dd>std::future object, which will be set when all pending background flush events have completed or have been cancelled. Ensure that the <a class="el" href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html" title="Client responsible for writing data into an OLP Stream Layer. ">StreamLayerClient</a> is not destructed prior to this future being set. </dd></dl>

</div>
</div>
<a id="a11051813f007b732533edcd0a25ea493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11051813f007b732533edcd0a25ea493">&#9670;&nbsp;</a></span>Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void olp::dataservice::write::StreamLayerClient::Enable </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classolp_1_1dataservice_1_1write_1_1FlushEventListener.html">FlushListener</a> &gt;&#160;</td>
          <td class="paramname"><em>listener</em> = <code>nullptr</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable the <a class="el" href="classolp_1_1dataservice_1_1write_1_1StreamLayerClient.html" title="Client responsible for writing data into an OLP Stream Layer. ">StreamLayerClient</a> auto-flushing mechanism. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">listener</td><td>Optional <a class="el" href="classolp_1_1dataservice_1_1write_1_1FlushEventListener.html" title="FlushEventListener is the listener that can be used to monitor the request flush events. Clients can provide concrete implementation by extending this class. ">FlushEventListener</a> used for optaining metrics and getting events related to auto flushing. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad385249de0e58e5778a94ec4f28f7b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad385249de0e58e5778a94ec4f28f7b93">&#9670;&nbsp;</a></span>Flush() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classolp_1_1client_1_1CancellableFuture.html">olp::client::CancellableFuture</a>&lt;FlushResponse&gt; olp::dataservice::write::StreamLayerClient::Flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush PublishDataRequests which have been queued via the Queue API. </p>
<dl class="section return"><dt>Returns</dt><dd>A CancellableFuture containing the FlushResponse. </dd></dl>

</div>
</div>
<a id="ab0d4842797842ce752773f3c99a8d24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d4842797842ce752773f3c99a8d24f">&#9670;&nbsp;</a></span>Flush() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classolp_1_1client_1_1CancellationToken.html">olp::client::CancellationToken</a> olp::dataservice::write::StreamLayerClient::Flush </td>
          <td>(</td>
          <td class="paramtype">const FlushCallback &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush PublishDataRequests which have been queued via the Queue API. </p>
<dl class="section return"><dt>Returns</dt><dd>A CancellationToken which can be used to cancel the ongoing request. </dd></dl>

</div>
</div>
<a id="ad132f0ced2ecd2653e892382d0df19d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad132f0ced2ecd2653e892382d0df19d7">&#9670;&nbsp;</a></span>PublishData() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classolp_1_1client_1_1CancellableFuture.html">olp::client::CancellableFuture</a>&lt;<a class="el" href="classolp_1_1client_1_1ApiResponse.html">PublishDataResponse</a>&gt; olp::dataservice::write::StreamLayerClient::PublishData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classolp_1_1dataservice_1_1write_1_1model_1_1PublishDataRequest.html">model::PublishDataRequest</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call to publish data into an OLP Stream Layer. </p>
<dl class="section note"><dt>Note</dt><dd>Content-type for this request will be set implicitly based on the Layer metadata for the target Layer on OLP. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>PublishDataRequest object representing the parameters for this publishData call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A CancellableFuture containing the PublishDataResponse. </dd></dl>

</div>
</div>
<a id="a7a286f9164cedc1cb1e4cbc62f723bc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a286f9164cedc1cb1e4cbc62f723bc4">&#9670;&nbsp;</a></span>PublishData() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classolp_1_1client_1_1CancellationToken.html">olp::client::CancellationToken</a> olp::dataservice::write::StreamLayerClient::PublishData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classolp_1_1dataservice_1_1write_1_1model_1_1PublishDataRequest.html">model::PublishDataRequest</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PublishDataCallback &amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call to publish data into an OLP Stream Layer. </p>
<dl class="section note"><dt>Note</dt><dd>Content-type for this request will be set implicitly based on the Layer metadata for the target Layer on OLP. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>PublishDataRequest object representing the parameters for this publishData call. </td></tr>
    <tr><td class="paramname">callback</td><td>PublishDataCallback which will be called with the PublishDataResponse when the operation completes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A CancellationToken which can be used to cancel the ongoing request. </dd></dl>

</div>
</div>
<a id="a7b6e93843c9c391d4e4c482386abc743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b6e93843c9c391d4e4c482386abc743">&#9670;&nbsp;</a></span>PublishSdii() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classolp_1_1client_1_1CancellableFuture.html">olp::client::CancellableFuture</a>&lt;<a class="el" href="classolp_1_1client_1_1ApiResponse.html">PublishSdiiResponse</a>&gt; olp::dataservice::write::StreamLayerClient::PublishSdii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classolp_1_1dataservice_1_1write_1_1model_1_1PublishSdiiRequest.html">model::PublishSdiiRequest</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call to send a list of SDII messages to an OLP Stream Layer. SDII message data must be in SDII MessageList protobuf format. For more information please see the OLP Sensor Data Ingestion Interface documentation and schemas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>PublishSdiiRequest object representing the parameters for this publishSdii call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A CancellableFuture containing the PublishSdiiResponse. </dd></dl>

</div>
</div>
<a id="a21679e30d6bdbd2d8d15a1867ee4f848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21679e30d6bdbd2d8d15a1867ee4f848">&#9670;&nbsp;</a></span>PublishSdii() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classolp_1_1client_1_1CancellationToken.html">olp::client::CancellationToken</a> olp::dataservice::write::StreamLayerClient::PublishSdii </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classolp_1_1dataservice_1_1write_1_1model_1_1PublishSdiiRequest.html">model::PublishSdiiRequest</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PublishSdiiCallback &amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Call to send a list of SDII messages to an OLP Stream Layer. SDII message data must be in SDII MessageList protobuf format. For more information please see the OLP Sensor Data Ingestion Interface documentation and schemas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>PublishSdiiRequest object representing the parameters for this publishSdii call. </td></tr>
    <tr><td class="paramname">callback</td><td>PublishSdiiCallback which will be called with the PublishSdiiResponse when the operation completes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A CancellationToken which can be used to cancel the ongoing request. </dd></dl>

</div>
</div>
<a id="a4861fa47c43c36f1ccf18bf995ce8df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4861fa47c43c36f1ccf18bf995ce8df4">&#9670;&nbsp;</a></span>Queue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boost::optional&lt;std::string&gt; olp::dataservice::write::StreamLayerClient::Queue </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classolp_1_1dataservice_1_1write_1_1model_1_1PublishDataRequest.html">model::PublishDataRequest</a> &amp;&#160;</td>
          <td class="paramname"><em>request</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Queue a PublishDataRequest to be sent over the wire at a later time. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">request</td><td>PublishDataRequest object representing the parameters for the call to be made in the future. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A boost optional which will be boost::none if the queue call was successful, otherwise it will contain a string with error details. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>olp-cpp-sdk-dataservice-write/include/olp/dataservice/write/<a class="el" href="StreamLayerClient_8h_source.html">StreamLayerClient.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
